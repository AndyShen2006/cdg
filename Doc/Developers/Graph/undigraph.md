# digraph的帮助文档
## 类Digraph：
### 构造函数：

实现方式：和平时做题差不多，就是模拟一个输入过程即可
### 生成函数：
generate函数是用于已构造的对象，可以把已构造的对象变成另外一幅图（类似一个语法糖）。对于其他的需要generate的地方，只要写generate(Digraph(...))即可。

实现的方法是先写一个能够完成generate工作的一个基础函数，这个函数的形式应该是generate(Digraph g)，之后，只需要调用Digraph的构造函数返回一个Digraph对象，然后调用这个generate就可以了。
### 随机函数：
随机数据包含两个函数(请注意，两个函数均需要填写所有规则，并且要按照帮助文档当中的顺序填写)：
第一个函数：定边生成函数（对于部分如空图等数据，边是确定的，故不需要指定边的条数。不支持：重边，自环，随机边，随机图）
对于这个函数，由于不实现重边，自环，随机边，只需要填写基础算法生成即可。

基础算法生成：

1.Complete：完全图，任意两点之间都有一条边

2.Empty：空图，无边

3.Tour：竞赛图（暂不实现）

4.Cycle：环图（1-n首尾顺次链接，然后n与1链接，最后使用random_shuffle和下标映射将节点和边打乱）

5.Star：菊花图（选中节点1，与余下n-1个点全部连一条边，然后打乱节点和边）

6.Wheel：轮图（节点1与余下所有点连一下，然后节点2-n顺次相连，最后打乱）

7.Chain：链（1-n首尾顺次相连即可）

8.Tree：树，此处不实现，直接调用Tree库

9.Pseudo：基环树（调用Tree库生成一棵树，然后随便选两个点连一条边）

10.BipartiteComplete：完全二分图，将节点随机分为两部分，第一部分的每一个节点往第二部分的每一个节点连一条边即可

11.Grid：网格图（将原有数据点数拆成两部分，第一部分是一个完全平方数，从而可以构建成一个网格矩阵,剩下点组成一条链直接和原图链接）

第二个函数：不定边生成函数（对于其他数据，指定边数，那么可以使用该函数生成到边数的边）（实现方法是先调用第一个函数生成定边图，然后生成随机边等特殊选项）

流程如下：指定边数，点数->生成定边图->根据边数生成随机边（如果已有边数大于允许边数，抛出异常（应该说明各算法至少要有多少边））

对于该函数，有五个选项

第一部分（是否生成随机边）：

1.Default：不生成随机边（当定边图/随机图生成完后自动返回，如果出现生成后边数不等于允许边数（特别是对于定边图生成），那么应该抛出异常）

2.Random：生成随机边：根据边数生成随机边（如果已有边数大于允许边数，抛出异常（应该说明各算法至少要有多少边））

第二部分（边的类型）（这个在生成随机边的时候会考虑）：

1.Multiple：允许重边

2.Simple：不允许重边

3.Loop：允许自环

4.Antiloop：不允许自环

第三部分（是否联通）：

1.Connected：该图全联通（实现的时候应该是不重边填上至少V-1条边，然后再考虑是否允许）

2.Disconneted：该图不一定全联通（没有任何章法，直接生成即可）

第四部分（基础算法生成）：

1.Normal：随机图（按照规则随机生成）

2.Tour：竞赛图（暂不实现）

3.Forest：森林，调用Tree库实现

4.Cactus：仙人掌（暂不实现）

5.Desert：沙漠（暂不实现）

6.Bipartite：二分图（暂不实现）

7.Grid：网格图（将原有数据点数拆成两部分，第一部分是一个完全平方数，从而可以构建成一个网格矩阵，余下的随便添）

第五部分（模板）

1.Simgraph：简单图：不包含重边，自环，所以包括了"Simple Antiloop"的规则

2.Multigraph：复杂图：包含重边，自环，所以包括了"Multiple Loop"的规则

3.Complete_Bipartite：完全二分图（暂不实现）

4.bypassSPFA：考虑不实现，因为SPFA优化过多，但是基本上大部分优化均可调用该库中函数bypass掉，所以不需要实现